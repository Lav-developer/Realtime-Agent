# Copilot instructions for Realtime Agent Chat

Purpose

- This small demo implements a realtime chat agent using Node.js + Express + Socket.IO with a static client in `public/`.
- Keep instructions concise and focused on patterns discovered in the codebase so an AI assistant can make safe, incremental changes.

```instructions
# Copilot instructions for Realtime Agent Chat

Purpose

- Minimal realtime chat demo: Node + Express server (`server.js`) serving static client files in `public/` and a Socket.IO endpoint. Client is vanilla HTML/JS/CSS.

Quick architecture (big picture)

- Single-process server: `server.js` holds an in-memory Map `users` keyed by `socket.id`. No persistence.
- Client: `public/index.html`, `public/client.js`, `public/styles.css` — manual DOM rendering and socket handlers.
- Socket flows: clients emit `join` and `message`. Server emits `users-list` (emitted to all clients), `user-joined`, `user-left`, and a `joined` ack to the joining socket.

Key files to read first

- `server.js` — server, socket handlers, in-memory user Map.
- `public/client.js` — socket usage, DOM rendering, system messages, and desktop notification handling.
- `public/index.html` — DOM IDs and structure referenced by the client.
- `package.json` — run scripts (`npm start`, `npm run dev`).

Project-specific conventions & patterns

- Short string socket event names: `join`, `joined` (ack), `message`, `users-list`, `user-joined`, `user-left`.
- The server is the source of truth for user IDs (socket.id). Client should accept the `joined` ack to learn its assigned id.
- `users-list` is emitted as an array of user objects to keep UI consistent — prefer that over DOM scraping.
- UI changes should be localized to `public/` and use the existing manual DOM helper functions (`renderUsers`, `addMessage`).

Notifications & UX

- The client requests Notification permission and shows desktop notifications for `user-joined` and `user-left` when allowed. See `public/client.js` for implementation.
- System messages are added to the chat feed with user `{ name: 'System' }`.

Developer workflows (how to build/run/test)

- Install and run (PowerShell):

```powershell
cd "d:\Lav Kush\College Project\Realtime Agent"
npm install
npm start
```

- For local dev with auto-reload: `npm run dev` (requires `nodemon`).
- Open multiple browser tabs at `http://localhost:3000` to validate join/message/user-left flows and desktop notifications.

Integration points & risks

- No external services; CORS can be configured via env var `CORS_ORIGIN` in `server.js`.
- State is ephemeral. Do not introduce persistence without a migration plan.
- Keep socket payload shapes stable — renaming events or changing required fields requires synchronized server+client edits.

Small allowed autonomous edits

- Fix provable client/server bugs (e.g., keep `users-list` consistent, set `me.id` from server ack, avoid DOM-scraping for user lists).
- Add small UX improvements inside `public/` (notifications, keyboard shortcuts) that don't change network protocol.

When to stop and ask a human

- Adding databases, auth, or deployment infra.
- Changing socket protocol (event names, required fields) without explicit coordination.
- Security-sensitive changes (rate-limiting, input sanitization) — ask for threat model and requirements.

Examples from the codebase

- server user join flow (see `server.js`): on `join` the server stores a normalized user object, broadcasts `user-joined`, emits updated `users-list` to all clients and sends a `joined` ack with the assigned id.
- client notification flow (see `public/client.js`): requests Notification permission and shows desktop notifications on `user-joined` / `user-left` when permission is granted.

If you update this file

- Keep edits short and reference changed files (e.g., "Updated `server.js` to emit `users-list` to all clients and added `joined` ack").

---
Generated by an automated assistant — please review and adjust for project policies.
```