# Copilot instructions for Realtime Agent Chat

Purpose

- This small demo implements a realtime chat agent using Node.js + Express + Socket.IO with a static client in `public/`.
- Keep instructions concise and focused on patterns discovered in the codebase so an AI assistant can make safe, incremental changes.

What this project is (big picture)

- Single-process Node server (`server.js`) that serves static files from `public/` and hosts a Socket.IO endpoint.
- Client is static HTML/JS/CSS in `public/` (`index.html`, `client.js`, `styles.css`).
- State (connected users) is stored in-memory in `server.js` using a Map — ephemeral and not persisted.

Key files to read first

- `server.js` — Web server, socket event handlers, and the simple in-memory user store.
- `public/client.js` — Client Socket.IO usage, DOM rendering for messages and user list.
- `public/index.html` — UI structure and bindings.
- `package.json` — scripts and dependency versions.

Project-specific patterns and conventions

- Socket event names are short strings: `join`, `message`, `users-list`, `user-joined`, `user-left`.
- All client-side rendering is manual DOM manipulation (no framework). When changing UI, prefer small, localized edits to `public/client.js` and `public/styles.css`.
- Server uses an in-memory Map `users` keyed by `socket.id`. Handle refactors carefully: any change to user shape must be coordinated between `server.js` and `public/client.js`.

Developer workflows (how to build/run/test)

- Install deps and start the server (PowerShell):

```powershell
cd "d:\Lav Kush\College Project\Realtime Agent"
npm install
npm start
```

- Dev iteration: use `npm run dev` to auto-restart the server (requires `nodemon`).
- The app is accessible at `http://localhost:3000` and the Socket.IO endpoint is at `/socket.io/`.

Safety and correctness expectations for code changes

- Do not add database or external services without adding a clear migration plan and configuration (this project is intentionally ephemeral).
- Preserve backwards-compatible socket event names. If a change renames an event, update both server and client in the same PR and include a short note in the commit message.
- Keep UI changes minimal and self-contained in `public/` when possible.

Examples to guide edits

- To add a `typing` indicator: replicate existing event patterns. Server: `socket.on('typing', () => io.broadcast.emit('typing', { user }))`. Client: `socket.emit('typing')` and `socket.on('typing', ...)` to show transient UI.
- To persist messages: add a new module `lib/store.js` exposing `appendMessage()` and `getRecent()` and call it from `server.js`. Do not replace the in-memory `users` Map without adding configuration and startup docs.

Common pitfalls found in the codebase

- `users-list` is emitted only to the connecting socket currently; other clients rely on `user-joined`/`user-left` events. If you change this behaviour, ensure all clients still receive consistent user lists.
- Client `user-joined` handler currently rebuilds the user list using DOM queries — a more reliable approach is to emit `users-list` to all clients after state mutations.

Small tasks the AI is allowed to do autonomously

- Fix small bugs that are provable locally (e.g., inconsistent DOM updates, missing null checks).
- Add helpful UX improvements inside `public/` (e.g., show user's name in the UI after joining, keyboard shortcuts).
- Add basic tests or linting configs if they are lightweight and don't change app behaviour.

When to stop and ask a human

- Adding persistent storage, auth, or deployment changes (Docker, cloud infra).
- Changing socket protocol (event names or payload shapes) that require coordination across clients or other services.
- Security-sensitive changes (input sanitization for displayed messages, rate-limiting). Ask for requirements and threat model.

Where to run tests and manual validation

- Manual validation: open multiple browser tabs at `http://localhost:3000` to verify join/message/user-left flows.
- No automated tests present; add minimal unit tests in `test/` only after confirming test runner choice.

If you update this file

- Keep it short. Describe only changes to socket events, state shape, or developer scripts.
- Reference the file(s) changed, e.g., "Updated `server.js` to emit `users-list` to all clients".

Questions for the repo owner

- Do you expect persistence or is ephemeral in-memory state acceptable for this project?
- Any plans to add authentication or named agent behaviours (bot logic) that should constrain event design?

---
Generated by an automated assistant — please review and adjust for project policies.